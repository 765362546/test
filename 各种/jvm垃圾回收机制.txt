
编译时环境：
程序的源文件  A.java  ----->   Java编译器(javac)   ----->   A.class

运行时环境：
程序的class文件   A.class   ------>  Java虚拟机  <------ （Java  API的class文件如：Object.class  String.class）

java虚拟机是什么？

Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包括一个类装载器（class loader），它可以从程序和API中装载class文件。Java API中只有程序执行时需要的哪些类才会被装载。字节码由引擎来执行。

要理解Java虚拟机，你首先必须意识到，当你说"Java虚拟机"时，可能指的是如下三种不同的东西：
1、抽象规范
2、一个具体的实现
3、一个运行中的虚拟机实例

Java虚拟机抽象规范仅仅是个概念。而该规范的具体实现，可能来自多个提供商，并存在于多个平台上。当运行一个Java程序的同时，也就在运行一个Java虚拟机实例

Java虚拟机的生命周期：
一个运行时的Java虚拟机实例的天职就是：负载运行一个Java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果在同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。

Java虚拟机实例通过调用初始类的main（）方法来运行一个Java程序。Java程序初始类中的main（）方法，将作为该程序初始线程的起点，任何其他的线程都是由这个初始线程启动的。


在java虚拟机内部有两种线程：守护线程与非守护线程。守护线程通常是由虚拟机自己使用的，比如执行垃圾收集任务的线程，只要还有任何非守护线程在运行，那么这个java程序也在继续运行（虚拟机任然存活）。当该程序中所有的非守护线程都终止时，虚拟机实例将自动退出。


    每个Java虚拟机都有一个类装载子系统，它根据给定的全限定名来装入类型（类或接口）。同样，每个Java虚拟机都有一个执行引擎，它负载执行那些包含在被装载类的方法中的指令。


+++++++++++++++++
 当Java虚拟机运行一个程序时，它需要内存来存储许多东西，例如：程序创建的对象，传递给方法的参数，返回值，局部变量，以及运算的中间结果等等。Java虚拟机把这些东西都组织到几个"运行时数据区"中，以便管理。

    某些运行时数据区是由程序中所有线程共享的，还有一些只能由一个线程拥有。每个Java虚拟机实例都有一个方法区以及一个堆，他们是由该虚拟机实例中所有线程共享的。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息。然后，它把这些类型信息放到方法区中。当程序运行时，虚拟机会把所有该程序在运行时创建的对象都放到堆中。
					--------------------------------------------------------------------		

   当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）以及一个Java栈。如果线程正在执行的是一个Java方法（非本地方法），那么PC寄存器的值将总是指示下一条将本执行的指令，而它的Java栈则总是存储该线程中Java方法调用的状态----包括它的局部变量，被调用时传进来的参数，它的返回值，以及运算的中间状态等等。而本地方法调用的状态，则是以某中依赖于具体实现的方式存储在本地方法栈中。
   
   
 =========================  
 
 
 Java虚拟机的体系结构
 

运行时数据区域
    Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。

    程序计数器：是一块较小的内容空间，它可以看作是当前线程执行的字节码行号指示器。

    栈：栈是线程私有的，它的生命周期与线程相同。 栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等消息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在栈中入栈到出栈的过程。

    Java虚拟机，对于栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

    本地方法栈：本地方法栈与虚拟机栈所发挥的作用非常相似，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用本地方法服务。


    堆：Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。虚拟机的堆大小可以通过-Xmx和-Xms控制。  如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常


    方法区：是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器后的代码等数据。
    当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常



    OutOfMemoryError异常总结：

    java堆溢出：实例
    -Xms：设置初始化堆大小
    -Xmx：设置堆最大可使用空间
    -XX:HeapDumpOnOutOfMemoryError：可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后进行分析。


	
	
 垃圾收集简称GC
 
 我的理解：
	垃圾回收分为两个动作，一是标记出哪些对象还存活，哪些已经死去，二是将死去的干掉。
	存活和死去：
		我的理解是，这个对象还有用，就标记为存活，没用了，就标记为死去；
		但是程序需要通过计算，比如可达性分析算法，来分析对象的状态，但是程序算出来的不一定靠谱，比如明明没用了，但是对象还一直活着，所以每经过一次gc，就给对象的年龄加1，超过一定年龄的，即使还活着，也干掉。。。



使用jvm运行程序时，开启GC日志：
-XX:+PrintGC 输出GC日志
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径

		
Java分代收集算法


Java主要采用了分代收集算法。分代收集算法主要将对象存储器的长短将内存进行划分
广泛地说，JVM堆内存被分为两部分：年轻代（Young Generator）和老年代（Old Generation）

Java堆新生代内存分配设置可以通过参数 -Xmn来设置， 如-Xmn10m 是给新生代分配10m的内存，如果这时堆大小设置为20m，那么剩下的10m就会被分配在老年代。

还可以通过-XX:NewRatio这个参数来设置年轻代和老年代的大小，这个参数是设置年轻代和老年代的空间比例，如-XX:NewRatio=4，表示年轻代和老年代的空间比例为1:4，默认值是2


年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫Minor GC。年轻代被分为3个部分----Ende区和两个Survivor区



年轻代中Ende区和两个Survivor区的占用内存空间大小设置
可以通过参数：-XX:SurvivorRatio来设置Ende区和两个Survivor区的空间比例；例如-XX:SurvivorRatio=2，表示ende区和两个Survivor的空间比为2:1:1
，默认值是8，即ende区和两个Srurvivo的空间比8:1:1

====
大多数新建的对象都位于Eden区。当Eden区被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个survivor区。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。(-XX:MaxTenuringThreshold 默认15) 这个值也可以调调，这个表示在新生代折腾多少次后进入年老代	
====

我的理解： 
	堆内存，分为年轻代和老年代，而年轻代又可以分成一个Eden区和两个Survivor区，这些区域的大小都可以调整。
	
	对象刚创建的时候，分配在Eden区，当Eden区满了之后，进行Minor GC----先标记里面死去的，然后把活着的放到一个survivor区，然后把整个Eden区干掉---这样可以防止出现内存碎片。
	当Eden区再次满了，在进行一次Minor GC---标记Eden和那个survivor区里面死去的，然后把两个区里面活着的，全都放到另外一个survivor里面，在把Eden和那个survivor全都干掉。
	总结起来就是新出生的放到Eden，然后Eden满了，就把所有活着的，包括survivor里面的，全都倒腾到另外一个survivor，然后干掉Eden和一个survivor-------总有一个空着的survivor。
	
老年代：老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。Major GC会花费更多的时间。
full gc = minor gc + major gc

====
Stop the World事件：所有的垃圾收集都是“Stop the World”事件，因为所有的应用线程都会停下来直到操作完成（所以叫“Stop the World”）。因为年轻代里的对象都是一些临时（short-lived ）对象，执行Minor GC非常快，所以应用不会受到（“Stop the World”）影响。由于Major GC会检查所有存活的对象，因此会花费更长的时间。应该尽量减少Major GC。因为Major GC会在垃圾回收期间让你的应用反应迟钝，所以如果你有一个需要快速响应的应用发生多次Major GC，你会看到超时错误。垃圾回收时间取决于垃圾回收策略。这就是为什么有必要去监控垃圾收集和对垃圾收集进行调优。从而避免要求快速响应的应用出现超时错误。
====	
	
我的理解： 
	执行GC的时候，会阻塞住所有线程，造成卡顿，年轻代中gc执行快，老年代中gc执行慢---------gc执行太频繁了，烧cpu，执行太少了，又会执行的慢，造成卡顿。
	调优点：
	老年代大小，调小了，可以加快老年代的gc，但是可能会出现内存溢出和gc太频繁，所以老年代的大小需要根据实际情况进行调优；
	进入老年代的年龄的设置，-XX:MaxTenuringThreshold，改大了，可以让对象尽可能的在年轻代被释放，但是有可能加重年轻代内存负担，也是需要观测。
	还有一种特殊情况，就是大对象，如果这种大对象比较多，很快就会把年轻代用完，频繁gc，可以设置大对象直接进入老年代，不经过年轻代，通过-XX:PretenureSizeThreshold（该设置只对Serial和ParNew收集器生效） 可以设置进入老生代的大小限制，单位是字节

-XX:PretenureSizeThreshold=3145728 ，此例为3M（3*1024*1024）
	


动态对象年龄判定:为了使内存分配更加灵活，虚拟机并不要求对象年龄达到MaxTenuringThreshold才晋升老年代,如果Survivor区中相同年龄所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象在Minor GC时将复制至老年代----------不一定非得达到MaxTenuringThreshold


空间分配担保：新生代使用复制算法，当Minor GC时如果存活对象过多，无法完全放入Survivor区，就会向老年代借用内存存放对象，以完成Minor GC。

在触发Minor GC时，虚拟机会先检测之前GC时租借的老年代内存的平均大小是否大于老年代的剩余内存，如果大于，则将Minor GC变为一次Full GC，如果小于，则查看虚拟机是否允许担保失败，如果允许担保失败，则只执行一次Minor GC，否则也要将Minor GC变为一次Full GC。

说白了，新生代放不下就会借用老年代的空间来进行GC


年轻代垃圾回收，采用复制算法，就是活着的，复制到survivor，然后干掉另外两个---所以年轻代gc快
老年代垃圾回收，采用压缩算法，刚开始老年代里面的内存是连续的，gc时，先干掉死去的，这是内存不连续了，gc会把那些对象重新排一下，整成连续的------老年代gc慢的原因